### **1. Analysis and Clarifications**

Before detailing the plan, here is an analysis of the existing codebase and a clarification of the requirements based on Zotero's documentation.

*   **Target Pages:** The implementation will target individual article pages generated by `src/pages/writing/[...slug].astro`.
*   **Layout Integration:** Metadata tags must be injected into the `<head>` of the final HTML, which is controlled by `src/layouts/BaseLayout.astro`. Data will need to be passed from the page template up to this base layout.
*   **Data Source:** All necessary metadata (title, authors, year, journal, DOI, etc.) is available in the `bibtex` string within the frontmatter of each markdown file in `src/content/writing/`. The associated PDF URL is available in the `pdfUrl` field.
*   **Existing Utilities:** The file `src/lib/citation-utils.ts` contains a `parseBibtex` function that can extract raw fields from the `bibtex` string. This utility should be extended, not replaced, to avoid redundant logic.
*   **Publication Types:** The codebase distinguishes between journal articles (`journal` field) and book chapters (`booktitle` field). Zotero requires different metadata for these. Specifically, book chapters use `citation_book_title` and can include `citation_editor`.
*   **Author Formatting:** Zotero strongly prefers the format `"Lastname, Firstname"` for personal names and unformatted strings for institutional authors (e.g., "The Committee for Public Information"). The new logic must handle the various formats present in the BibTeX data.
*   **Multiple Authors/Editors:** Zotero requires a separate `<meta>` tag for each author or editor. A single tag with semicolon-separated names is not compliant.

### **2. Detailed Implementation Plan**

This plan is broken down into four main steps, focusing on creating a robust, maintainable, and testable solution.

---

#### **Step 1: Enhance Citation Utilities (`src/lib/citation-utils.ts`)**

The core logic will reside here. We will add new functions to parse and format the data specifically for Zotero metadata, leveraging the existing `parseBibtex` function.

**A. Create an Author/Editor Formatting Utility:**
This function will be the most complex part, designed to handle all identified edge cases.

*   **File:** `src/lib/citation-utils.ts`
*   **New Function:** `export function formatContributorsForZotero(nameString: string): string[]`
*   **Logic:**
    1.  Accepts a raw `author` or `editor` string from BibTeX.
    2.  Splits the string by " and " to get individual contributors.
    3.  For each contributor string:
        *   Trim whitespace.
        *   **Institutional Author Check:** If the string is wrapped in double curly braces (e.g., `{{The Royal Society}}`), remove the braces and return the name as is.
        *   **Pre-formatted Check:** If the string contains a comma (e.g., `"Butterfill, Stephen A."`), assume it's already in the correct "Last, First" format and return it.
        *   **Standard Name Parsing:** If no comma is found, assume "First Middle Last" format. Split the name by spaces. The last word is the last name. The preceding words are the first/middle names. Reassemble as `"Lastname, Firstname Middlename"`.
        *   **Handle Braced Names:** Before parsing, remove protective curly braces around parts of names (e.g., `{della Gatta}, Francesco` becomes `della Gatta, Francesco`). The existing `cleanBibtexField` function can be used or adapted for this.
    4.  The function will return an array of correctly formatted contributor names.

**B. Create a Page Range Parsing Utility:**

*   **File:** `src/lib/citation-utils.ts`
*   **New Function:** `export function parsePageRange(pages: string): { first: string; last: string }`
*   **Logic:**
    1.  Accepts a `pages` string (e.g., "53--60", "23-47", "104601").
    2.  Normalize various dash types (`--`, `–`, `—`) to a standard hyphen (`-`).
    3.  Split the string by the hyphen.
    4.  Return an object `{ first: parts[0], last: parts[1] || parts[0] }`.

**C. Create the Main Metadata Generation Function:**

*   **File:** `src/lib/citation-utils.ts`
*   **New Function:** `export function generateZoteroMetadata(entry: AstroContentEntry): Record<string, any>`
*   **Logic:**
    1.  Accept the full Astro `entry` object as an argument to access both `bibtex` and `pdfUrl`.
    2.  Call `parseBibtex(entry.data.bibtex)` to get a raw data object.
    3.  Initialize an empty `metadata` object.
    4.  **Determine Publication Type:**
        *   If `parsed.journal` exists, set `metadata.publication_type = 'journalArticle'`.
        *   Else if `parsed.booktitle` exists, set `metadata.publication_type = 'bookSection'`.
    5.  **Populate Metadata:**
        *   `metadata.citation_title = parsed.title;`
        *   `metadata.citation_author = formatContributorsForZotero(parsed.author);`
        *   `metadata.citation_publication_date = parsed.year;`
        *   `metadata.citation_doi = parsed.doi;`
        *   `metadata.citation_pdf_url = entry.data.pdfUrl;` (The full URL will be constructed in the layout).
    6.  **Type-Specific Fields:**
        *   If `journalArticle`:
            *   `metadata.citation_journal_title = parsed.journal;`
            *   `metadata.citation_volume = parsed.volume;`
            *   `metadata.citation_issue = parsed.number;`
        *   If `bookSection`:
            *   `metadata.citation_book_title = parsed.booktitle;`
            *   If `parsed.editor`, `metadata.citation_editor = formatContributorsForZotero(parsed.editor);`
    7.  **Parse Pages:**
        *   If `parsed.pages`, call `parsePageRange` and add `citation_firstpage` and `citation_lastpage` to `metadata`.
    8.  Return the populated `metadata` object.

---

#### **Step 2: Update Article Page Template (`src/pages/writing/[...slug].astro`)**

This file will orchestrate the data generation and pass it to the layout.

*   **File:** `src/pages/writing/[...slug].astro`
*   **Modifications:**
    1.  Import the new `generateZoteroMetadata` function.
    2.  Inside the component script, call the function:
        ```javascript
        import { generateZoteroMetadata } from '../../lib/citation-utils';
        // ...
        const { entry } = Astro.props;
        const zoteroMetadata = generateZoteroMetadata(entry);
        ```
    3.  Pass the resulting `zoteroMetadata` object as a prop to the `PageLayout` component, which will forward it to `BaseLayout`.
        ```xml
        <PageLayout title={entry.data.title} contextualActions={pageActions} zoteroMetadata={zoteroMetadata}>
          ...
        </PageLayout>
        ```

---

#### **Step 3: Update Layouts to Render Metadata**

The `BaseLayout` needs to be updated to accept the metadata and render the tags.

*   **File:** `src/layouts/PageLayout.astro`
*   **Modification:** Add `zoteroMetadata` to the `Props` interface and pass it through to `BaseLayout`.
    ```javascript
    interface Props {
      title: string;
      contextualActions?: any[];
      zoteroMetadata?: Record<string, any>; // Add this
    }
    const { title, contextualActions, zoteroMetadata } = Astro.props;
    // ...
    <BaseLayout title={title} contextualActions={contextualActions} zoteroMetadata={zoteroMetadata}>
    ```

*   **File:** `src/layouts/BaseLayout.astro`
*   **Modifications:**
    1.  Update the `Props` interface to accept `zoteroMetadata`.
        ```javascript
        interface Props {
          title: string;
          contextualActions?: any[];
          zoteroMetadata?: Record<string, any>; // Add this
        }
        const { title, contextualActions, zoteroMetadata } = Astro.props;
        ```
    2.  In the `<head>` section, add the logic to render the meta tags. This logic must handle arrays (for authors/editors) and only render tags for which data exists.
        ```xml
        <head>
          ...
          {zoteroMetadata && (
            <>
              {zoteroMetadata.citation_title && <meta name="citation_title" content={zoteroMetadata.citation_title} />}
              {zoteroMetadata.citation_author?.map(author => (
                <meta name="citation_author" content={author} />
              ))}
              {zoteroMetadata.citation_editor?.map(editor => (
                <meta name="citation_editor" content={editor} />
              ))}
              {zoteroMetadata.citation_publication_date && <meta name="citation_publication_date" content={zoteroMetadata.citation_publication_date} />}
              {zoteroMetadata.citation_journal_title && <meta name="citation_journal_title" content={zoteroMetadata.citation_journal_title} />}
              {zoteroMetadata.citation_book_title && <meta name="citation_book_title" content={zoteroMetadata.citation_book_title} />}
              {zoteroMetadata.citation_volume && <meta name="citation_volume" content={zoteroMetadata.citation_volume} />}
              {zoteroMetadata.citation_issue && <meta name="citation_issue" content={zoteroMetadata.citation_issue} />}
              {zoteroMetadata.citation_firstpage && <meta name="citation_firstpage" content={zoteroMetadata.citation_firstpage} />}
              {zoteroMetadata.citation_lastpage && <meta name="citation_lastpage" content={zoteroMetadata.citation_lastpage} />}
              {zoteroMetadata.citation_doi && <meta name="citation_doi" content={zoteroMetadata.citation_doi} />}
              {zoteroMetadata.citation_pdf_url && <meta name="citation_pdf_url" content={Astro.url.origin + zoteroMetadata.citation_pdf_url} />}
            </>
          )}
        </head>
        ```

---

### **3. Risk Assessment and Mitigation**

*   **Risk 1 (High): Complex Author Name Parsing.** BibTeX author fields are notoriously inconsistent. The proposed `formatContributorsForZotero` function might fail on unforeseen edge cases.
    *   **Mitigation:**
        1.  Create a comprehensive test suite for this function using all identified edge cases from the codebase and more.
        2.  Implement a fallback: if parsing fails for a specific name, log a warning during the build process and output the name as-is.
        3.  Prioritize correctness for the most common formats.

*   **Risk 2 (Medium): Incomplete or Malformed BibTeX Data.** An entry might be missing a `journal` or `booktitle`, leading to incorrect publication type detection.
    *   **Mitigation:** The logic will default to a generic publication type if neither field is present. The conditional rendering in `BaseLayout.astro` ensures that only available metadata is outputted, gracefully degrading the citation quality rather than breaking the page.

*   **Risk 3 (Low): Performance.** Adding more logic to the build process.
    *   **Mitigation:** This is a static site, so all parsing happens at build time. The impact on user-facing performance is zero. The impact on build time will be negligible as it's simple string processing on a few dozen files.

*   **Risk 4 (Low): Zotero Extension Behavior.** The Zotero extension might change its parsing priorities in the future.
    *   **Mitigation:** The plan prioritizes Highwire Press tags, which are the de facto standard and the most stable target. Adding Dublin Core tags as a secondary layer could increase future compatibility.

---

### **4. Definition of Done**

The task will be considered complete when the following criteria are met:

1.  **Code Implementation:**
    *   [ ] All new utility functions (`formatContributorsForZotero`, `parsePageRange`, `generateZoteroMetadata`) are created in `src/lib/citation-utils.ts`.
    *   [ ] The `[...slug].astro` page template correctly calls `generateZoteroMetadata` and passes the result to the layout.
    *   [ ] The `BaseLayout.astro` file correctly and conditionally renders all relevant `citation_*` meta tags in the `<head>` section.
    *   [ ] Multiple authors and editors are rendered as separate, repeated `<meta>` tags.

2.  **Functionality and Correctness:**
    *   [ ] Visiting an article page (e.g., `/writing/collective_goals/`) shows the correct metadata in the page source (`view-source:`).
    *   [ ] The Zotero Connector browser extension successfully detects and saves a "Journal Article" for entries with a `journal` field.
    *   [ ] The Zotero Connector successfully detects and saves a "Book Section" for entries with a `booktitle` field.
    *   [ ] When a `pdfUrl` is present in the frontmatter, the Zotero Connector automatically attaches the PDF to the saved item.
    *   [ ] All identified author name edge cases are correctly formatted as "Lastname, Firstname".
    *   [ ] Page ranges with various dash formats are correctly parsed into `citation_firstpage` and `citation_lastpage`.

3.  **Quality and Testing:**
    *   [ ] The implementation has been tested against a representative sample of articles from the codebase, including `butterfill2017_coordinating.md` (book chapter with editor) and `clarke2019_joint.md` (journal article with multiple authors).
    *   [ ] The local development server (`npm run dev`) and production build (`npm run build`) complete without errors.
    *   [ ] The solution does not introduce any visual regressions or runtime errors on the article pages.